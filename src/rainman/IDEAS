new Peer scheduler interface:

PeerBroker(object):
  MIN_LEECH_RATE = Amount(1, Data.MB)    # capped leech rate if we are not a downloader

  def __init__(self, on_handshake=None, on_interested=None, on_new_piece=None):
    out_queue = []
    in_queue  = []

  def request(slice)
  def cancel(slice)
  def have(piece)
  def unchoke()

  algorithm:
    while active:
      while did_work and queues not empty:
        did_work = False
        if requests and not interested:
          yield set interested
        if no outbound requests in X seconds:
          yield set not interested
        if we get a request for interested:
          if on_interested and on_interested(self):  # only allow uploads if
            yield set unchoke                        # we've registered an interested policy
        if no inbound requests in X seconds and unchoked:
          yield choke
        if outgoing requests:
          empty out queue
        if incoming requests:
          while outgoing bandwidth < min(MIN_LEECH_RATE, incoming bandwidth):
            fulfill one request
      yield gen.Task(self.ioloop.add_callback)


Get rid of the linear cost of a bunch of pieces and instead make it M lg M
where M << N.

Scheduler:
  __init__(self, session):
    self._session = session
    self._session.filemanager.add_on_finish_callback(self.new_piece)
    self._new_finishes = []
    self._need = calculate_the_pieces_i_need

  def scheduler:
    while active:
      need -= new_finishes
      

Session:
  bitfield = Bitfield(...)
  for k in range(num_pieces):
    bitfield[k] = FileManager.has(k)
  new_pieces = set()

  def manage_new_pieces(...):
     for piece in self.new_pieces:
        for peer in filter(None, self._connections.values()):
            peer.have(index)
     for piece in self.new_pieces:
        self.bitfield[piece] = True
     self.new_pieces = set()

  def new_piece_arrived(self, index):
     self.new_pieces.add(index)


FileManager(session, on_new_piece_callback)
   def update_cache(index):
     ...
     if on_new_piece_callback:
        on_new_piece_callback(index)
  


